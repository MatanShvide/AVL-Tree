פונקציית בדיקה לשאלה 1 עיוני:

	public static void main(String[] args) {
		/*AVLTree tree = new AVLTree();
		AVLTree randomTree = new AVLTree();
		int sum = 0;
		Random generator = new Random();
		int n = 
				2000;
		for (int i=n; i>0; i--) {
			sum += tree.searchFromMax(i);
			tree.insert(i, "String of" + i);
		}
		System.out.println(sum);
		sum=0;
		int [] bank4= new int[n];
		int[] orderOfInsertions4 = new int[n];
		for (int i=0; i<n; i++) { //create first tree
			int key = tester.getRandomInt3(generator, bank4); //get random number under 500
			String info = "String of" + key;
			sum += randomTree.searchFromMax(key);
			randomTree.insert(key, info);
			orderOfInsertions4[i] = key; //keep order of insertions for deeper checking if necessary
		}
		System.out.println(sum);
		//System.out.println(Arrays.toString(orderOfInsertions4));
		int subCnt = 0;
		for (int i=0; i<n; i++) {
			for (int j=0; j<n; j++) {
				if ((i>j)&&(orderOfInsertions4[i]<orderOfInsertions4[j])) {
					subCnt+=1;
				}
			}
		}
		System.out.println(subCnt);
	}
	
	public static int getRandomInt3(Random randomGen, int[] bank4) { //only under 500
		int key = randomGen.nextInt(bank4.length);
		while (bank4[key]==1) {
			key = randomGen.nextInt(bank4.length);	
	}
		bank4[key]=1;
		return key;
	}
}*/






פונקציית בדיקה לטסטר:

	public void print(AVLNode node, int level) { /////aux tester func
		if (node == null) {
			return;
		}
		//System.out.println("Level: " + level + " , " + node.getKey() + " , " + node.getValue());
		if ((node.key != -1) && ((node.getBF() >= 2) || (node.getBF() <= -2))) {
			System.out.println("node" + node.key + " is unbalanced. BF is " + node.getBF() + ". sons are "
					+ node.left.key + " rank=" + node.left.rank + " " + node.right.key + " rank=" + node.right.rank
					+ "*********");
		} else if (((node.right != null) && (node.right.key < node.key) && (node.right.key != -1))
				|| ((node.left != null) && (node.left.key > node.key) && (node.left.key != -1))) {
			System.out.println("node" + node.key + "is not in order********");
		} else if ((node.rank == -1) && ((node.right != null) || (node.left != null))) {
			System.out.println("virtual son of" + node.parent.key + " has a son*********");
		} else if ((node.right != null) && (node.right.parent != node)
				|| ((node.left != null) && (node.left.parent != node))) {
			System.out.println("one of" + node.key + "sons is not connected to him*********");
		} else if ((node.parent != null) && (node.parent.right != node) && (node.parent.left != node)) {
			System.out.println("node" + node.key + " is not connected to parent********");
		} else if ((node.rank != -1) && (node.rank != (Math.max(node.left.rank, node.right.rank) + 1))) {
			System.out.println("node" + node.key + " rank is not adjusted, his rank is" + node.rank);
			System.out.println("sons are" + node.left.key + " rank " + node.left.rank + " and " + node.right.key
					+ " rank " + node.right.rank);
		}

		if (node.getLeft() != null)
			print((AVLNode) (node.getLeft()), level + 1);
		if (node.getRight() != null)
			print((AVLNode) node.getRight(), level + 1);
	}


פונקציית חובה בAVLNODE למען ריצת הטסטר:

		private int getBF() {
			if (this.rank == -1) {
				return -3;
			}
			return this.left.rank - this.right.rank;
		}
